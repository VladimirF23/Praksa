version: '3-8'

services:

  flask-app-praksa:
    build: .                                                  #buildujemo flask-app-prakse image koristeci DockerFile u ovom direktorijumu
    container_name: flask-app-praksa
    env_file:
      - ./devinfoDocker.env
    ports:
      - "5000:5000"                                           #flask
      - "5678:5678"                                           #debugpy

    environment:
      - MYSQL_HOST=${MYSQL_HOST}
      - MYSQL_PORT=${MYSQL_PORT}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DB=${MYSQL_DB_NAME}
      - GEVENT_SUPPORT=True                                     # da bi radilo debugovanje
    depends_on:                                                 #osigurava redosled pokretanja flask saceka redis i mysql pokrenu pre njega, ali ne i readines, Flask app treba sam da ceka MySQL i Redis da budu availible
      - redis-praksa
      - mysql_db-praksa

    volumes:
      - .:/usr/src/app                                          # mapira direktorijum sa lokalne masine na /usr/src/app unutar kontjnera, dozvoljava LIVE CODE changes bez rebuilodvanja kontejnera
    working_dir: /usr/src/app                                   # Osiguramo da se Flask pokrece iz ovog direktorijuma
    entrypoint: ["/bin/bash", "./wait-for-mysql.sh"]            # U depends garantuje order po kom se pokrece a ne garantuje je da je mysql skroz spreman za primanje konekc...
                                                                # ovaj entryPoint ne mora da se napise jer je vec napisan u DockerFile-u, ali cisto da se zna sta se desava sam ostavio kad se gleda docker-compose
    networks:              
                                                                #- frontend-network  dobijace preko nginx-a zahteve, ovako je sigurnije jer flask-app nije direktno dostupan preko interneta i ovako ce isto u production-u biti
      - backend-network-praksa 

  mysql_db-praksa:
    image: mysql:8.0
    container_name: mysql_db-praksa
    env_file:
      - ./devinfoDocker.env 
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DB_NAME}
    volumes:                               
      - mysql_db-data-praksa:/var/lib/mysql                           # Mountujem Volume u moj container, volume se koriste radi perzisentcije podataka cak kada se i container obrise
      - ./dumpPraksa.sql:/docker-entrypoint-initdb.d/dumpPraksa.sql   # Mountujem sa mog kompa fajl gde sam inicijalizovao mysql bazu podataka i dodao neke dummy podatke
    networks:                                             
      - backend-network-praksa

  redis-praksa:
    image: redis:alpine         
    container_name: redis-praksa
    env_file:
      - ./devinfoDocker.env    
    command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"]    # command over-riduje default command koja pokrece redis u kontenieru, redis server pokrece redis service unutar redis container-a i zahteva da svaka konekcija na reddis
    networks:                                                          # zahteva sifru 
      - backend-network-praksa                                             
    volumes:                                                         
      - redis-data-praksa:/data                                        # mountujemo redis volume unutar data foldera u container-u da bi imali perzisenticiju podataka koji se cuvaju u volume-u


                                                                       
  react_frontend-praksa:                                               # React frontend ce se IZBACITI za production posto ce nginx servovati  pre-built static fajlove iz mount-ovanog volume
    build: 
      context: ./Frontend                                              # Lokacija DockerFile-a
    volumes:
    - ./Frontend/my-app:/app                                           # Mountujemo 'my-app' folder sa mog kompjutera u '/app' unutar container
    - react_node_modules-praksa:/app/node_modules                      # react_node_modules je docker volume koji ce docker menagovati i koji ce spreciti node_modules da budu overwritovani ako se code promeni lokalno reflectovace se u containeru ali se dependecy nece wipovati
    command: ["npm", "start"]                   
    container_name: react_frontend-praksa
    ports:
      - "3000:3000"
    networks:
      - frontend-network-praksa      

  nginx-praksa:
    build:
      context: ./nginx
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - flask-app-praksa
      - react_frontend-praksa
    networks:
      - frontend-network-praksa
      - backend-network-praksa
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro                     # mount-ujemo  config za development
      - ./nginx/certs:/etc/nginx/certs:ro                               #ovako je najbolje zbog sigurnosti, napisao sam u nginx docker file zato da ne koristim COPY tih cert, ro ->read only


  celery-worker:
    build: .
    container_name: celery-worker-praksa
    command: celery -A celery_app.celery worker --loglevel=info --without-mingle --pool=gevent --concurrency=5    #, Mingle was causing a significant delay (over a minute and a half) during the worker startup. Using --without-mingle removes this discovery phase, allowing your worker to become ready to process tasks almost instantly after connecting to Redis.
    entrypoint: ""  # override default entrypoint

    depends_on:
      - redis-praksa  # Celery only depends on Redis
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    networks:
      - backend-network-praksa

  celery-beat:
    build: .
    container_name: celery-beat-praksa
    command: celery -A celery_app.celery beat --loglevel=info
    entrypoint: ""

    depends_on:
      - redis-praksa
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    networks:
      - backend-network-praksa

networks:
  backend-network-praksa:                                              # koristimo takodje 2 networka zbog bezbednosti NGINX ce imati pristup oba ali sa interneta se nece moci direktno pristupiti backendu bez da se prodje NGINX proxy 
      driver: bridge                                                   # koristi dockerov bridge network mode -> conteineri na ovom networku mogu izmedju sebe da komunciraju jedni sa drugima izolovani od host machine
  frontend-network-praksa:
      driver: bridge    

volumes:
    mysql_db-data-praksa:                  
    redis-data-praksa:
    react_node_modules-praksa:                    
